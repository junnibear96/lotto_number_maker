<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>로또 6/45 번호 뽑기</title>
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2064%2064'%3E%3Cdefs%3E%3CradialGradient%20id='g'%20cx='35%25'%20cy='30%25'%20r='80%25'%3E%3Cstop%20offset='0%25'%20stop-color='%232dd4bf'/%3E%3Cstop%20offset='55%25'%20stop-color='%237c5cff'/%3E%3Cstop%20offset='100%25'%20stop-color='%230b1220'/%3E%3C/radialGradient%3E%3C/defs%3E%3Ccircle%20cx='32'%20cy='32'%20r='28'%20fill='url(%23g)'/%3E%3Ccircle%20cx='32'%20cy='32'%20r='28'%20fill='none'%20stroke='rgba(234,240,255,0.25)'%20stroke-width='2'/%3E%3Ctext%20x='32'%20y='38'%20text-anchor='middle'%20font-family='system-ui,Segoe%20UI,Arial'%20font-size='18'%20font-weight='800'%20fill='%23eaf0ff'%3E6%2F45%3C/text%3E%3C/svg%3E" />
  <style>
    :root {
      --bg: #0b1220;
      --card: #0f1a2e;
      --text: #eaf0ff;
      --muted: #b8c3e6;
      --border: rgba(234, 240, 255, 0.16);
      --accent: #7c5cff;
      --accent-2: #2dd4bf;
      --danger: #fb7185;
    }

    :root {
      color-scheme: dark;
    }

    body {
      margin: 0;
      padding: 24px;
      line-height: 1.6;
      background: var(--bg);
      color: var(--text);
    }

    main {
      max-width: 860px;
      margin: 0 auto;
    }

    h1 {
      margin: 0 0 8px 0;
      letter-spacing: -0.02em;
    }

    h2 {
      letter-spacing: -0.01em;
    }

    .muted {
      color: var(--muted);
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      margin: 16px 0;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .controls-row {
      margin-left: auto;
      justify-content: flex-end;
      flex: 1;
    }

    .stack {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .stack-right {
      align-items: flex-end;
      text-align: right;
    }

    label {
      font-weight: 600;
    }

    select,
    button,
    input {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.03);
      color: var(--text);
    }

    select {
      background: var(--card);
    }

    option {
      background: var(--card);
      color: var(--text);
    }

    select:focus,
    button:focus {
      outline: 2px solid rgba(124, 92, 255, 0.45);
      outline-offset: 2px;
    }

    input:focus {
      outline: 2px solid rgba(124, 92, 255, 0.45);
      outline-offset: 2px;
    }

    button {
      cursor: pointer;
      background: linear-gradient(135deg, rgba(124, 92, 255, 0.95), rgba(45, 212, 191, 0.9));
      border: 0;
      font-weight: 700;
    }

    button:active {
      transform: translateY(1px);
    }

    .numbers {
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.02em;
    }

    #numbers {
      display: grid;
      gap: 6px;
      white-space: normal;
    }

    .numbers-line {
      display: flex;
      gap: 10px;
      align-items: baseline;
    }

    .numbers-idx {
      color: var(--muted);
      font-weight: 900;
      min-width: 34px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
    }

    .stat {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
    }

    .stat .label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .stat .value {
      font-size: 18px;
      font-weight: 700;
    }

    .divider {
      height: 1px;
      background: var(--border);
      margin: 14px 0;
    }

    .list {
      display: grid;
      gap: 10px;
    }

    .list-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
    }

    .list-title {
      font-weight: 800;
      letter-spacing: 0.01em;
    }

    .list-meta {
      margin-top: 6px;
      color: var(--muted);
      font-size: 13px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.03);
      font-weight: 700;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    details.overlap-details {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
    }

    details.overlap-details>summary {
      cursor: pointer;
      font-weight: 800;
    }

    details.overlap-details[open]>summary {
      margin-bottom: 10px;
    }

    .history {
      display: grid;
      gap: 10px;
    }

    .history-item {
      position: relative;
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      padding-right: 52px;
      background: rgba(255, 255, 255, 0.02);
    }

    .history-left {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 220px;
    }

    .history-title {
      font-weight: 700;
    }

    .history-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: flex-end;
    }

    .history-delete {
      position: absolute;
      top: -12px;
      right: -12px;
      width: 30px;
      height: 30px;
      padding: 0;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      line-height: 1;
      background: var(--card);
      box-shadow: 0 0 0 3px var(--card);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--border);
      font-weight: 700;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
      background: rgba(11, 18, 32, 0.6);
      z-index: 50;
    }

    .modal-backdrop[hidden] {
      display: none !important;
    }

    .modal {
      width: min(520px, 100%);
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 0 0 1px rgba(234, 240, 255, 0.04) inset;
    }

    .modal-title {
      margin: 0 0 8px 0;
      font-weight: 900;
      letter-spacing: -0.01em;
    }

    .modal-message {
      margin: 0;
      color: var(--muted);
    }

    .modal-actions {
      margin-top: 14px;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .toast {
      position: fixed;
      right: 18px;
      bottom: 18px;
      z-index: 60;
      width: min(420px, calc(100% - 36px));
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px 14px;
      box-shadow: 0 0 0 1px rgba(234, 240, 255, 0.04) inset;
    }

    .toast[hidden] {
      display: none !important;
    }

    .toast-title {
      font-weight: 900;
      margin: 0 0 4px 0;
    }

    .toast-message {
      margin: 0;
      color: var(--muted);
    }

    pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
    }

    @media (max-width: 720px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 720px) {
      .history-item {
        flex-direction: column;
        align-items: stretch;
      }

      .history-actions {
        justify-content: stretch;
      }
    }
  </style>
</head>

<body>
  <main>
    <header>
      <div class="row" style="justify-content: space-between; align-items: flex-start;">
        <div>
          <h1>로또 6/45 번호 뽑기</h1>
          <div class="muted">1~45에서 6개 번호를 뽑고, 과거 당첨 조합을 제외할 수 있어요.</div>
        </div>
        <div class="row" style="justify-content: flex-end;">
          <button id="goOverlaps" type="button" class="btn-secondary">겹치는 조합 보기</button>
          <button id="goFrequency" type="button" class="btn-secondary">번호 빈도 히트맵</button>
          <button id="goSimulator" type="button" class="btn-secondary">당첨 확률 시뮬레이터</button>
          <button id="goCompare" type="button" class="btn-secondary">추첨 번호 확인하기</button>
        </div>
      </div>
    </header>

    <section class="card" aria-label="Overlap overview">
      <h2 style="margin: 0 0 8px 0;">겹침 통계 (히스토리 기준)</h2>
      <div class="muted" style="margin-bottom: 12px;">
        과거 회차 데이터로 계산한 “겹침(count)”과 “비율(%)”입니다.
      </div>
      <div id="overlapGrid" class="grid" aria-live="polite">
        <div class="stat">
          <span class="label">1등 ↔ 다른 회차 1등</span>
          <div class="value" id="statFirstVsFirst">Loading…</div>
        </div>
        <div class="stat">
          <span class="label">2등 ↔ 다른 회차 1등</span>
          <div class="value" id="statSecondVsFirst">Loading…</div>
        </div>
        <div class="stat">
          <span class="label">2등 ↔ 다른 회차 2등</span>
          <div class="value" id="statSecondVsSecond">Loading…</div>
        </div>
        <div class="stat">
          <span class="label">3등 ↔ 다른 회차 1등</span>
          <div class="value" id="statThirdVsFirst">Loading…</div>
        </div>
        <div class="stat">
          <span class="label">3등 ↔ 다른 회차 2등</span>
          <div class="value" id="statThirdVsSecond">Loading…</div>
        </div>
      </div>
      <div class="muted" id="overlapMeta" style="margin-top: 12px;"></div>
    </section>

    <section class="card" aria-label="Draw controls">
      <div class="row" style="justify-content: space-between; align-items: flex-start;">
        <div>
          <label for="mode">제외 옵션</label>
          <div class="muted">어떤 과거 조합을 피할지 선택하세요.</div>
        </div>
        <div class="row controls-row">
          <div class="stack stack-right">
            <label for="excludeNumbers" class="muted" style="font-weight: 700;">제외할 번호 (선택)</label>
            <input id="excludeNumbers" type="text" inputmode="numeric" autocomplete="off"
              placeholder="예: 1, 2, 3 또는 1 2 3" aria-label="제외할 번호 입력" />
            <div class="muted" style="font-size: 13px;">쉼표/공백으로 구분. 1~45, 최대 39개까지.</div>
          </div>

          <div class="stack stack-right">
            <label for="fixedNumbers" class="muted" style="font-weight: 700;">고정 번호 (선택)</label>
            <input id="fixedNumbers" type="text" inputmode="numeric" autocomplete="off" placeholder="예: 7 또는 7, 13"
              aria-label="고정 번호 입력" />
            <div class="muted" style="font-size: 13px;">1~45, 최대 2개. 나머지만 랜덤.</div>
          </div>

          <div class="stack stack-right">
            <label for="drawCount" class="muted" style="font-weight: 700;">몇 게임</label>
            <input id="drawCount" type="number" min="1" max="50" step="1" value="1" aria-label="한 번에 뽑을 게임 수" />
            <div class="muted" style="font-size: 13px;">1~50</div>
          </div>
          <select id="mode" aria-label="제외 옵션">
            <option value="NONE">랜덤 뽑기 (제외 없음)</option>
            <option value="FIRST">과거 1등 조합 제외</option>
            <option value="SECOND">과거 2등 조합 제외</option>
            <option value="THIRD">과거 3등 조합 제외</option>
            <option value="ALL">과거 1·2·3등 조합 모두 제외</option>
          </select>
          <button id="drawBtn" type="button">뽑기</button>
        </div>
      </div>

      <div style="margin-top: 12px;">
        <details class="overlap-details" id="advancedAccordion">
          <summary>
            고급 옵션
            <span id="advancedSummaryInline" class="muted"
              style="margin-left: 8px; font-weight: 600; font-size: 13px;"></span>
          </summary>

          <div id="advancedSummary" class="muted" style="margin-top: 8px;">현재: 연속=상관없음 · 끝수중복=허용 · 구간필터=OFF</div>

          <div class="row" style="justify-content: space-between; align-items: flex-start; margin-top: 10px;">
            <div class="stack" style="gap: 10px; flex: 1; min-width: 260px;">
              <div class="muted" style="font-weight: 800;">조건부 필터 뽑기</div>
              <div class="muted" style="font-size: 13px;">체크/슬라이더로 조합 성향을 제어합니다. (선택사항)</div>

              <div class="row" style="align-items: center;">
                <label class="muted" style="font-weight: 800;">연속 번호</label>
                <label class="chip" style="cursor: pointer;">
                  <input type="radio" name="optConsecutive" value="ALLOW" checked style="margin-right: 8px;" />
                  상관없음
                </label>
                <label class="chip" style="cursor: pointer;">
                  <input type="radio" name="optConsecutive" value="REQUIRE" style="margin-right: 8px;" />
                  포함
                </label>
                <label class="chip" style="cursor: pointer;">
                  <input type="radio" name="optConsecutive" value="FORBID" style="margin-right: 8px;" />
                  제외
                </label>
              </div>

              <div class="row" style="align-items: center;">
                <label class="muted" style="font-weight: 800;">끝수 중복</label>
                <label class="chip" style="cursor: pointer;">
                  <input type="radio" name="optLastDigit" value="ALLOW" checked style="margin-right: 8px;" />
                  허용
                </label>
                <label class="chip" style="cursor: pointer;">
                  <input type="radio" name="optLastDigit" value="FORBID" style="margin-right: 8px;" />
                  제외 (예: 3,13,23)
                </label>
              </div>

              <div class="row" style="align-items: center;">
                <label class="muted" style="font-weight: 800;">전 주와 중복</label>
                <label class="chip" style="cursor: pointer;">
                  <input id="optPrevOverlap" type="checkbox" style="margin-right: 8px;" />
                  3개 이상 겹침 제외
                </label>
              </div>
            </div>

            <div class="stack" style="gap: 10px; flex: 1; min-width: 260px; align-items: flex-end; text-align: right;">
              <div class="muted" style="font-weight: 800;">특정 구간 최소/최대 개수</div>

              <div class="row" style="justify-content: flex-end; align-items: center;">
                <label class="chip" style="cursor: pointer;">
                  <input id="optRangeEnabled" type="checkbox" style="margin-right: 8px;" />
                  구간 필터 사용
                </label>
              </div>

              <div class="row" style="justify-content: flex-end; align-items: center;">
                <label for="optRangeBucket" class="muted" style="font-weight: 800;">구간</label>
                <select id="optRangeBucket" aria-label="구간 선택">
                  <option value="1-10">1~10</option>
                  <option value="11-20">11~20</option>
                  <option value="21-30">21~30</option>
                  <option value="31-40">31~40</option>
                  <option value="41-45">41~45</option>
                </select>
              </div>

              <div class="stack" style="gap: 8px; width: 100%;">
                <div class="row" style="justify-content: flex-end; align-items: center;">
                  <span class="muted" style="font-weight: 800;">최소</span>
                  <input id="optRangeMin" type="range" min="0" max="6" step="1" value="0" style="flex: 1;" />
                  <span id="optRangeMinVal" class="chip">0</span>
                </div>
                <div class="row" style="justify-content: flex-end; align-items: center;">
                  <span class="muted" style="font-weight: 800;">최대</span>
                  <input id="optRangeMax" type="range" min="0" max="6" step="1" value="6" style="flex: 1;" />
                  <span id="optRangeMaxVal" class="chip">6</span>
                </div>
              </div>

              <div class="muted" style="font-size: 13px;">예: 1~10 구간에서 2~3개 포함</div>
            </div>
          </div>

          <div style="margin-top: 14px; border-top: 1px solid var(--border); padding-top: 12px;">
            <div class="row" style="justify-content: space-between; align-items: flex-start; gap: 12px;">
              <div class="stack" style="gap: 8px; flex: 1; min-width: 260px;">
                <div class="muted" style="font-weight: 800;">히스토리 제외 (선택)</div>
                <div class="muted" style="font-size: 13px;">선택한 히스토리의 “6개 조합”이 다시 나오지 않게 제외합니다.</div>
                <div id="historyExcludeList" class="stack" style="gap: 8px;"></div>
              </div>
              <div class="stack" style="gap: 8px; align-items: flex-end; text-align: right;">
                <button id="historyExcludeClear" type="button" class="btn-secondary">전체 해제</button>
                <div class="muted" style="font-size: 13px;">(여러 개 선택 가능)</div>
              </div>
            </div>
          </div>
        </details>
      </div>
    </section>

    <section class="card" aria-label="Draw result">
      <h2 style="margin: 0 0 8px 0;">결과</h2>
      <div class="numbers" id="numbers">(“번호 뽑기”를 눌러주세요)</div>
      <details style="margin-top: 10px;">
        <summary class="muted">원본 응답(JSON)</summary>
        <pre id="result"></pre>
      </details>
    </section>

    <section class="card" aria-label="Analysis summary">
      <h2 style="margin: 0 0 8px 0;">분석 요약</h2>
      <div class="muted" style="margin-bottom: 12px;">번호 합계 / 홀짝 비율 / 구간 분포(1~10, 11~20, …)</div>
      <div id="analysisSummary" class="list" aria-live="polite"></div>
      <div id="analysisSummaryEmpty" class="muted">결과가 나오면 자동으로 분석됩니다.</div>
    </section>

    <section class="card" aria-label="Draw history">
      <div class="row" style="justify-content: space-between; align-items: center;">
        <h2 style="margin: 0;">히스토리</h2>
        <div class="row" style="justify-content: flex-end;">
          <button id="copyHistoryBtn" type="button" class="btn-secondary">Copy</button>
          <button id="copylocalStorageBtn" type="button" class="btn-secondary">저장하기</button>
          <button id="downloadHistoryBtn" type="button" class="btn-secondary">Excel 다운로드</button>
        </div>
      </div>
      <div class="muted" style="margin-bottom: 12px;">결과가 누적됩니다. 각 줄에서 “결과 번호 제외”를 누르면 현재 “결과”의 6개 번호를 제외해서 뽑고, “재뽑기”는
        왼쪽 번호를 제외해서 다시 뽑아요.</div>
      <div id="history" class="history" aria-live="polite"></div>
      <div id="historyEmpty" class="muted">아직 기록이 없어요.</div>
    </section>
  </main>

  <div id="appAlert" class="modal-backdrop" hidden>
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="appAlertTitle"
      aria-describedby="appAlertMessage">
      <h3 id="appAlertTitle" class="modal-title">알림</h3>
      <p id="appAlertMessage" class="modal-message"></p>
      <div class="modal-actions">
        <button id="appAlertCancel" type="button" class="btn-secondary">취소</button>
        <button id="appAlertOk" type="button">확인</button>
      </div>
    </div>
  </div>

  <div id="appToast" class="toast" hidden>
    <div id="appToastTitle" class="toast-title">완료</div>
    <p id="appToastMessage" class="toast-message"></p>
  </div>

  <script>
    const resultEl = document.getElementById('result');
    const numbersEl = document.getElementById('numbers');
    const analysisSummaryEl = document.getElementById('analysisSummary');
    const analysisSummaryEmptyEl = document.getElementById('analysisSummaryEmpty');
    const modeEl = document.getElementById('mode');
    const redrawBtn = document.getElementById('drawBtn');
    const randomBtn = document.getElementById('randomBtn');
    const excludeNumbersEl = document.getElementById('excludeNumbers');
    const fixedNumbersEl = document.getElementById('fixedNumbers');
    const drawCountEl = document.getElementById('drawCount');
    const historyEl = document.getElementById('history');
    const historyEmptyEl = document.getElementById('historyEmpty');
    const copyHistoryBtn = document.getElementById('copyHistoryBtn');
    const copyLocalStorageBtn = document.getElementById('copylocalStorageBtn');
    const downloadHistoryBtn = document.getElementById('downloadHistoryBtn');
    const appAlertEl = document.getElementById('appAlert');
    const appAlertTitleEl = document.getElementById('appAlertTitle');
    const appAlertMessageEl = document.getElementById('appAlertMessage');
    const appAlertOkEl = document.getElementById('appAlertOk');
    const appAlertCancelEl = document.getElementById('appAlertCancel');
    const appToastEl = document.getElementById('appToast');
    const appToastTitleEl = document.getElementById('appToastTitle');
    const appToastMessageEl = document.getElementById('appToastMessage');

    const optConsecutiveEls = document.querySelectorAll('input[name="optConsecutive"]');
    const optLastDigitEls = document.querySelectorAll('input[name="optLastDigit"]');
    const optRangeEnabledEl = document.getElementById('optRangeEnabled');
    const optRangeBucketEl = document.getElementById('optRangeBucket');
    const optRangeMinEl = document.getElementById('optRangeMin');
    const optRangeMaxEl = document.getElementById('optRangeMax');
    const optRangeMinValEl = document.getElementById('optRangeMinVal');
    const optRangeMaxValEl = document.getElementById('optRangeMaxVal');
    const advancedSummaryEl = document.getElementById('advancedSummary');
    const advancedSummaryInlineEl = document.getElementById('advancedSummaryInline');

    const historyExcludeListEl = document.getElementById('historyExcludeList');
    const historyExcludeClearEl = document.getElementById('historyExcludeClear');

    let toastTimer = null;

    let cachedOverlapData = null;

    document.getElementById('goOverlaps')?.addEventListener('click', () => {
      window.location.href = '/overlaps';
    });

    document.getElementById('goFrequency')?.addEventListener('click', () => {
      window.location.href = '/frequency';
    });

    document.getElementById('goSimulator')?.addEventListener('click', () => {
      window.location.href = '/simulator';
    });

    document.getElementById('goCompare')?.addEventListener('click', () => {
      window.location.href = '/compare';
    });

    const history = [];
    const STORAGE_KEY = 'lotto_history_v1';

    let historyIdSeq = 1;
    const excludedHistoryIds = new Set();

    function saveHistory() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
      } catch (e) {
        console.error('saveHistory failed', e);
      }
    }

    function loadHistory() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) {
            history.length = 0;
            let maxId = 0;
            parsed.forEach((item) => {
              history.push(item);
              if (item.id && typeof item.id === 'string' && item.id.startsWith('h')) {
                const n = parseInt(item.id.substring(1), 10);
                if (!Number.isNaN(n) && n > maxId) maxId = n;
              }
            });
            historyIdSeq = maxId + 1;
          }
        }
      } catch (e) {
        console.error('loadHistory failed', e);
      }
      renderHistory();
    }

    function ensureHistoryItemIds() {
      history.forEach((item) => {
        if (!item) return;
        if (!item.id) item.id = `h${historyIdSeq++}`;
      });
    }

    function currentHistoryIndexById(id) {
      return history.findIndex((it) => it?.id === id);
    }

    function getExcludeDrawsFromHistorySelection() {
      if (!excludedHistoryIds.size) return [];
      const out = [];
      Array.from(excludedHistoryIds).forEach((id) => {
        const idx = currentHistoryIndexById(id);
        const item = idx >= 0 ? history[idx] : null;
        if (!item || !Array.isArray(item.numbers) || item.numbers.length !== 6) return;
        out.push(item.numbers);
      });
      return out;
    }

    function renderHistoryExcludeUI() {
      if (!historyExcludeListEl) return;
      ensureHistoryItemIds();

      Array.from(excludedHistoryIds).forEach((id) => {
        if (currentHistoryIndexById(id) < 0) excludedHistoryIds.delete(id);
      });

      historyExcludeListEl.innerHTML = '';

      if (!history.length) {
        const empty = document.createElement('div');
        empty.className = 'muted';
        empty.style.fontSize = '13px';
        empty.textContent = '히스토리가 없어요. (결과를 뽑으면 목록이 생깁니다)';
        historyExcludeListEl.appendChild(empty);
        syncAdvancedUI();
        return;
      }

      history.forEach((item, idx) => {
        if (!item || !Array.isArray(item.numbers) || item.numbers.length !== 6) return;

        const label = document.createElement('label');
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        label.style.gap = '10px';
        label.style.padding = '8px 10px';
        label.style.borderRadius = '10px';
        label.style.border = '1px solid var(--border)';
        label.style.background = 'rgba(255,255,255,0.03)';
        label.style.cursor = 'pointer';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = excludedHistoryIds.has(item.id);
        cb.addEventListener('change', () => {
          if (cb.checked) excludedHistoryIds.add(item.id);
          else excludedHistoryIds.delete(item.id);
          syncAdvancedUI();
        });

        const text = document.createElement('div');
        text.className = 'muted';
        text.style.fontWeight = '800';
        text.style.flex = '1';
        text.textContent = `#${idx + 1}  ${item.numbers.join(', ')}`;

        label.appendChild(cb);
        label.appendChild(text);
        historyExcludeListEl.appendChild(label);
      });

      syncAdvancedUI();
    }

    historyExcludeClearEl?.addEventListener('click', () => {
      excludedHistoryIds.clear();
      renderHistoryExcludeUI();
    });

    const MODE_OPTIONS = [
      { value: 'NONE', label: '랜덤 뽑기 (제외 없음)' },
      { value: 'FIRST', label: '과거 1등 조합 제외' },
      { value: 'SECOND', label: '과거 2등 조합 제외' },
      { value: 'THIRD', label: '과거 3등 조합 제외' },
      { value: 'ALL', label: '과거 1·2·3등 조합 모두 제외' },
    ];

    function showAlert(message, title = '알림') {
      if (!appAlertEl || !appAlertTitleEl || !appAlertMessageEl) {
        // Fallback
        alert(String(message));
        return;
      }
      if (appAlertCancelEl) appAlertCancelEl.style.display = 'none';
      appAlertTitleEl.textContent = String(title);
      appAlertMessageEl.textContent = String(message);
      appAlertEl.hidden = false;
      appAlertOkEl?.focus();
    }

    function hideAlert() {
      if (!appAlertEl) return;
      appAlertEl.hidden = true;
    }

    let confirmResolver = null;

    function showConfirm(message, title = '확인') {
      return new Promise((resolve) => {
        if (!appAlertEl || !appAlertTitleEl || !appAlertMessageEl) {
          resolve(window.confirm(String(message)));
          return;
        }

        confirmResolver = resolve;
        if (appAlertCancelEl) appAlertCancelEl.style.display = '';
        appAlertTitleEl.textContent = String(title);
        appAlertMessageEl.textContent = String(message);
        appAlertEl.hidden = false;
        appAlertOkEl?.focus();
      });
    }

    appAlertOkEl?.addEventListener('click', () => {
      hideAlert();
      if (typeof confirmResolver === 'function') {
        const r = confirmResolver;
        confirmResolver = null;
        r(true);
      }
    });

    appAlertCancelEl?.addEventListener('click', () => {
      hideAlert();
      if (typeof confirmResolver === 'function') {
        const r = confirmResolver;
        confirmResolver = null;
        r(false);
      }
    });

    // Defensive: ensure modal is not visible on initial load.
    hideAlert();

    function showToast(message, title = '완료', ms = 1400) {
      if (!appToastEl || !appToastTitleEl || !appToastMessageEl) return;
      if (toastTimer) {
        clearTimeout(toastTimer);
        toastTimer = null;
      }
      appToastTitleEl.textContent = String(title);
      appToastMessageEl.textContent = String(message);
      appToastEl.hidden = false;
      toastTimer = setTimeout(() => {
        appToastEl.hidden = true;
        toastTimer = null;
      }, ms);
    }

    function syncAdvancedUI() {
      const mn = Number.parseInt(String(optRangeMinEl?.value ?? '0'), 10);
      const mx = Number.parseInt(String(optRangeMaxEl?.value ?? '6'), 10);
      const fixedMin = Number.isInteger(mn) ? mn : 0;
      let fixedMax = Number.isInteger(mx) ? mx : 6;
      if (fixedMin > fixedMax) {
        fixedMax = fixedMin;
        if (optRangeMaxEl) optRangeMaxEl.value = String(fixedMax);
      }
      if (optRangeMinValEl) optRangeMinValEl.textContent = String(fixedMin);
      if (optRangeMaxValEl) optRangeMaxValEl.textContent = String(fixedMax);

      const enabled = Boolean(optRangeEnabledEl?.checked);
      const controls = [optRangeBucketEl, optRangeMinEl, optRangeMaxEl];
      controls.forEach((el) => {
        if (!el) return;
        el.disabled = !enabled;
        el.style.opacity = enabled ? '1' : '0.6';
      });

      // Summary line
      const consecutiveMode = String(document.querySelector('input[name="optConsecutive"]:checked')?.value ?? 'ALLOW');
      const lastDigitMode = String(document.querySelector('input[name="optLastDigit"]:checked')?.value ?? 'ALLOW');

      const consecutiveLabel = consecutiveMode === 'REQUIRE' ? '포함' : (consecutiveMode === 'FORBID' ? '제외' : '상관없음');
      const lastDigitLabel = lastDigitMode === 'FORBID' ? '제외' : '허용';
      const prevOverlapLabel = document.getElementById('optPrevOverlap')?.checked ? '3개이상제외' : '허용';

      let rangeLabel = 'OFF';
      if (enabled) {
        const bucket = String(optRangeBucketEl?.value ?? '1~10').replace('-', '~');
        rangeLabel = `${bucket} ${fixedMin}~${fixedMax}개`;
      }

      let historyLabel = '없음';
      if (excludedHistoryIds.size) {
        const idxs = Array.from(excludedHistoryIds)
          .map((id) => currentHistoryIndexById(id))
          .filter((i) => i >= 0)
          .map((i) => i + 1)
          .sort((a, b) => a - b);

        if (idxs.length) {
          const head = idxs.slice(0, 4).map((n) => `#${n}`).join(',');
          historyLabel = idxs.length > 4 ? `${head}…(${idxs.length}개)` : head;
        }
      }

      const summaryText = `현재: 연속=${consecutiveLabel} · 끝수중복=${lastDigitLabel} · 전주중복=${prevOverlapLabel} · 구간필터=${rangeLabel}`;

      if (advancedSummaryEl) {
        advancedSummaryEl.textContent = summaryText;
      }
      if (advancedSummaryInlineEl) {
        advancedSummaryInlineEl.textContent = summaryText;
      }
    }

    optConsecutiveEls?.forEach((el) => el.addEventListener('change', syncAdvancedUI));
    optLastDigitEls?.forEach((el) => el.addEventListener('change', syncAdvancedUI));
    optRangeEnabledEl?.addEventListener('change', syncAdvancedUI);
    optRangeMinEl?.addEventListener('input', syncAdvancedUI);
    optRangeMaxEl?.addEventListener('input', syncAdvancedUI);
    document.getElementById('optPrevOverlap')?.addEventListener('change', syncAdvancedUI);
    syncAdvancedUI();

    function getAdvancedOptionsFromUI() {
      const consecutive_mode = String(document.querySelector('input[name="optConsecutive"]:checked')?.value ?? 'ALLOW');
      const last_digit_mode = String(document.querySelector('input[name="optLastDigit"]:checked')?.value ?? 'ALLOW');

      const enabled = Boolean(optRangeEnabledEl?.checked);
      const bucket = String(optRangeBucketEl?.value ?? '1-10');
      const min_count = Number.parseInt(String(optRangeMinEl?.value ?? '0'), 10);
      const max_count = Number.parseInt(String(optRangeMaxEl?.value ?? '6'), 10);

      return {
        consecutive_mode,
        last_digit_mode,
        range_filter: {
          enabled,
          bucket,
          min_count: Number.isInteger(min_count) ? min_count : 0,
          max_count: Number.isInteger(max_count) ? max_count : 6,
          max_count: Number.isInteger(max_count) ? max_count : 6,
        },
        max_previous_draw_overlap: document.getElementById('optPrevOverlap')?.checked ? 2 : 6,
      };
    }

    appAlertOkEl?.addEventListener('click', hideAlert);
    appAlertEl?.addEventListener('click', (e) => {
      if (e.target === appAlertEl) hideAlert();
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && appAlertEl && !appAlertEl.hidden) hideAlert();
    });

    function modeLabel(value) {
      const opt = MODE_OPTIONS.find((o) => o.value === value);
      return opt?.label ?? String(value ?? '');
    }

    function escapeHtml(text) {
      return String(text)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function historyRows() {
      return history.map((h, idx) => ({
        no: idx + 1,
        numbers: Array.isArray(h?.numbers) ? h.numbers.join(', ') : '',
        mode: modeLabel(h?.mode),
      }));
    }

    async function copyHistoryToClipboard() {
      const rows = historyRows();
      const header = ['No', 'Numbers', 'Mode'].join('\t');
      const body = rows.map((r) => [r.no, r.numbers, r.mode].join('\t')).join('\n');
      const text = rows.length ? `${header}\n${body}` : header;

      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.setAttribute('readonly', '');
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        return ok;
      }
    }

    function downloadHistoryAsExcel() {
      const rows = historyRows();
      const tableRows = rows
        .map((r) => `<tr><td>${escapeHtml(r.no)}</td><td>${escapeHtml(r.numbers)}</td><td>${escapeHtml(r.mode)}</td></tr>`)
        .join('');

      const html = `<!doctype html><html><head><meta charset="utf-8"></head><body><table border="1"><thead><tr><th>No</th><th>Numbers</th><th>Mode</th></tr></thead><tbody>${tableRows}</tbody></table></body></html>`;
      const blob = new Blob([html], { type: 'application/vnd.ms-excel;charset=utf-8' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      const now = new Date();
      const pad = (n) => String(n).padStart(2, '0');
      const stamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
      a.download = `lotto_history_${stamp}.xls`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    copyHistoryBtn?.addEventListener('click', async () => {
      if (history.length === 0) {
        showAlert('기록이 없습니다');
        return;
      }
      copyHistoryBtn.disabled = true;
      copyHistoryBtn.style.opacity = '0.7';
      try {
        const ok = await copyHistoryToClipboard();
        if (!ok) {
          showAlert('복사에 실패했어요.');
          return;
        }
        showToast('히스토리를 클립보드에 복사했어요.');
      } finally {
        copyHistoryBtn.disabled = false;
        copyHistoryBtn.style.opacity = '1';
      }
    });

    downloadHistoryBtn?.addEventListener('click', () => {
      if (history.length === 0) {
        showAlert('기록이 없습니다');
        return;
      }
      downloadHistoryBtn.disabled = true;
      downloadHistoryBtn.style.opacity = '0.7';
      try {
        downloadHistoryAsExcel();
        showToast('엑셀 다운로드를 시작했어요.');
      } finally {
        downloadHistoryBtn.disabled = false;
        downloadHistoryBtn.style.opacity = '1';
      }
    });

    copyLocalStorageBtn?.addEventListener('click', () => {
      if (history.length === 0) {
        showAlert('기록이 없습니다');
        return;
      }
      saveHistory();
      showToast('모든 결과가 로컬 스토리지에 저장되었습니다.');
    });

    function fmtPct(p) {
      if (typeof p !== 'number' || Number.isNaN(p)) return '—';
      if (p === 0) return '0%';
      return `${p.toFixed(4)}%`;
    }

    function setStat(id, count, denom, pct) {
      const el = document.getElementById(id);
      if (!el) return;
      el.textContent = `${count} (${fmtPct(pct)})`;
      el.title = `count=${count}, denominator=${denom}`;
    }

    async function ensureOverlapData() {
      if (cachedOverlapData) return cachedOverlapData;
      const res = await fetch('/analysis/overlap');
      const payload = await res.json();
      if (!res.ok || !payload.success) throw new Error('Failed to load overlap stats');
      cachedOverlapData = payload.data;
      return cachedOverlapData;
    }

    async function loadOverlapOverview() {
      try {
        const data = await ensureOverlapData();
        const stats = data.overlap_percentages;
        const denom1 = stats?.denominators?.unique_1st_place_combinations ?? 0;
        const denom2 = stats?.denominators?.unique_2nd_place_combinations ?? 0;
        const denom3 = stats?.denominators?.unique_3rd_place_combinations ?? 0;
        const counts = stats?.counts ?? {};
        const pct = stats?.percent ?? {};

        setStat('statFirstVsFirst', counts['1st_overlapping_other_1st'] ?? 0, denom1, pct['1st_overlapping_other_1st']);
        setStat('statSecondVsFirst', counts['2nd_overlapping_other_1st'] ?? 0, denom2, pct['2nd_overlapping_other_1st']);
        setStat('statSecondVsSecond', counts['2nd_overlapping_other_2nd'] ?? 0, denom2, pct['2nd_overlapping_other_2nd']);
        setStat('statThirdVsFirst', counts['3rd_overlapping_other_1st'] ?? 0, denom3, pct['3rd_overlapping_other_1st']);
        setStat('statThirdVsSecond', counts['3rd_overlapping_other_2nd'] ?? 0, denom3, pct['3rd_overlapping_other_2nd']);

        const metaEl = document.getElementById('overlapMeta');
        if (metaEl) {
          metaEl.textContent = `분모(유니크 조합 수): 1등=${denom1}, 2등=${denom2}, 3등=${denom3}`;
        }
      } catch (e) {
        const ids = ['statFirstVsFirst', 'statSecondVsFirst', 'statSecondVsSecond', 'statThirdVsFirst', 'statThirdVsSecond'];
        ids.forEach((id) => {
          const el = document.getElementById(id);
          if (el) el.textContent = 'Unavailable';
        });
        const metaEl = document.getElementById('overlapMeta');
        if (metaEl) metaEl.textContent = String(e);
      }
    }

    loadOverlapOverview();

    function setDrawingState(isDrawing) {
      if (redrawBtn) {
        redrawBtn.disabled = isDrawing;
        redrawBtn.style.opacity = isDrawing ? '0.7' : '1';
      }
      if (randomBtn) {
        randomBtn.disabled = isDrawing;
        randomBtn.style.opacity = isDrawing ? '0.7' : '1';
      }
    }

    async function postDraw(payload) {
      const res = await fetch('/draw', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const json = await res.json();
      return { res, json };
    }

    function clearEl(el) {
      if (!el) return;
      while (el.firstChild) el.removeChild(el.firstChild);
    }

    function analyzeNumbers(nums) {
      const numbers = (Array.isArray(nums) ? nums : []).map((n) => Number(n)).filter((n) => Number.isInteger(n));
      const sum = numbers.reduce((acc, n) => acc + n, 0);
      const odd = numbers.filter((n) => n % 2 === 1).length;
      const even = numbers.length - odd;

      const step = 20;
      const bandStart = Math.floor(sum / step) * step;
      const bandEnd = bandStart + step - 1;
      const band = `${bandStart}~${bandEnd}`;

      const bins = [
        { label: '1~10', min: 1, max: 10 },
        { label: '11~20', min: 11, max: 20 },
        { label: '21~30', min: 21, max: 30 },
        { label: '31~40', min: 31, max: 40 },
        { label: '41~45', min: 41, max: 45 },
      ];
      const dist = bins.map((b) => {
        const c = numbers.filter((n) => n >= b.min && n <= b.max).length;
        return { label: b.label, count: c };
      });

      return { sum, band, odd, even, dist };
    }

    function renderAnalysisSummary(drawn) {
      if (!analysisSummaryEl) return;
      clearEl(analysisSummaryEl);

      const rows = [];
      if (Array.isArray(drawn) && drawn.length && Array.isArray(drawn[0])) {
        // multi draw
        drawn.forEach((row) => {
          if (Array.isArray(row) && row.length === 6) rows.push(row);
        });
      } else if (Array.isArray(drawn) && drawn.length === 6) {
        rows.push(drawn);
      }

      if (!rows.length) {
        if (analysisSummaryEmptyEl) analysisSummaryEmptyEl.style.display = 'block';
        return;
      }

      if (analysisSummaryEmptyEl) analysisSummaryEmptyEl.style.display = 'none';

      rows.forEach((nums, idx) => {
        const a = analyzeNumbers(nums);

        const item = document.createElement('div');
        item.className = 'list-item';

        const title = document.createElement('div');
        title.className = 'list-title';
        title.textContent = rows.length > 1 ? `#${idx + 1} 분석` : '현재 결과 분석';

        const grid = document.createElement('div');
        grid.className = 'grid';
        grid.style.marginTop = '10px';

        const s1 = document.createElement('div');
        s1.className = 'stat';
        const s1Label = document.createElement('span');
        s1Label.className = 'label';
        s1Label.textContent = '번호 합계';
        const s1Value = document.createElement('div');
        s1Value.className = 'value';
        s1Value.textContent = `${a.sum} (구간 ${a.band})`;
        s1.appendChild(s1Label);
        s1.appendChild(s1Value);

        const s2 = document.createElement('div');
        s2.className = 'stat';
        const s2Label = document.createElement('span');
        s2Label.className = 'label';
        s2Label.textContent = '홀수:짝수';
        const s2Value = document.createElement('div');
        s2Value.className = 'value';
        s2Value.textContent = `${a.odd}:${a.even}`;
        s2.appendChild(s2Label);
        s2.appendChild(s2Value);

        const s3 = document.createElement('div');
        s3.className = 'stat';
        const s3Label = document.createElement('span');
        s3Label.className = 'label';
        s3Label.textContent = '구간 분포';
        const s3Value = document.createElement('div');
        s3Value.className = 'value';
        s3Value.style.fontSize = '14px';
        s3Value.style.fontWeight = '800';
        s3Value.textContent = a.dist.map((d) => `${d.label}:${d.count}`).join(' / ');
        s3.appendChild(s3Label);
        s3.appendChild(s3Value);

        grid.appendChild(s1);
        grid.appendChild(s2);
        grid.appendChild(s3);

        item.appendChild(title);
        item.appendChild(grid);
        analysisSummaryEl.appendChild(item);
      });
    }

    function showDrawResult(payload) {
      const data = payload?.data ?? {};
      const draws = data?.draws;
      const numbers = data?.numbers;

      function clearNumbersEl() {
        if (!numbersEl) return;
        while (numbersEl.firstChild) numbersEl.removeChild(numbersEl.firstChild);
      }

      function setSingleLine(text) {
        clearNumbersEl();
        if (!numbersEl) return;
        const div = document.createElement('div');
        div.textContent = String(text);
        numbersEl.appendChild(div);
      }

      // Multi-draw
      if (Array.isArray(draws) && draws.length) {
        clearNumbersEl();
        draws.forEach((row, idx) => {
          const line = document.createElement('div');
          line.className = 'numbers-line';

          const badge = document.createElement('span');
          badge.className = 'numbers-idx';
          badge.textContent = `#${idx + 1}`;

          const text = document.createElement('span');
          text.textContent = Array.isArray(row) ? row.join(', ') : '';

          line.appendChild(badge);
          line.appendChild(text);
          numbersEl.appendChild(line);
        });
        resultEl.textContent = JSON.stringify(payload, null, 2);
        renderAnalysisSummary(draws);
        return draws;
      }

      // Single draw
      if (!Array.isArray(numbers)) {
        setSingleLine('Error');
        resultEl.textContent = JSON.stringify(payload, null, 2);
        renderAnalysisSummary(null);
        return null;
      }
      setSingleLine(numbers.join(', '));
      resultEl.textContent = JSON.stringify(payload, null, 2);
      renderAnalysisSummary(numbers);
      return numbers;
    }

    function getCurrentResultNumbers() {
      const text = String(numbersEl?.textContent ?? '');
      const nums = (text.match(/\d+/g) ?? []).map((n) => Number.parseInt(n, 10));
      const unique = Array.from(new Set(nums)).filter((n) => Number.isInteger(n) && n >= 1 && n <= 45);
      if (unique.length !== 6) return null;
      unique.sort((a, b) => a - b);
      return unique;
    }

    function parseExcludeNumbers(text) {
      const raw = String(text ?? '').trim();
      if (!raw) return [];

      const nums = (raw.match(/\d+/g) ?? []).map((n) => Number.parseInt(n, 10));
      const unique = Array.from(new Set(nums)).filter((n) => Number.isInteger(n));

      const invalid = unique.filter((n) => n < 1 || n > 45);
      if (invalid.length) {
        throw new Error(`제외 번호는 1~45만 가능해요. 잘못된 값: ${invalid.join(', ')}`);
      }
      if (unique.length > 39) {
        throw new Error('제외 번호가 너무 많아요. 최대 39개까지 가능해요.');
      }
      if (45 - unique.length < 6) {
        throw new Error('제외 번호가 너무 많아서 6개를 뽑을 수 없어요.');
      }

      unique.sort((a, b) => a - b);
      return unique;
    }

    function parseFixedNumbers(text) {
      const raw = String(text ?? '').trim();
      if (!raw) return [];

      const nums = (raw.match(/\d+/g) ?? []).map((n) => Number.parseInt(n, 10));
      const unique = Array.from(new Set(nums)).filter((n) => Number.isInteger(n));

      const invalid = unique.filter((n) => n < 1 || n > 45);
      if (invalid.length) {
        throw new Error(`고정 번호는 1~45만 가능해요. 잘못된 값: ${invalid.join(', ')}`);
      }
      if (unique.length > 2) {
        throw new Error('고정 번호는 최대 2개까지 가능해요.');
      }

      unique.sort((a, b) => a - b);
      return unique;
    }

    function getExcludeNumbersFromInput() {
      try {
        return parseExcludeNumbers(excludeNumbersEl?.value);
      } catch (e) {
        showAlert(String(e));
        return null;
      }
    }

    function getFixedNumbersFromInput() {
      try {
        return parseFixedNumbers(fixedNumbersEl?.value);
      } catch (e) {
        showAlert(String(e));
        return null;
      }
    }

    function validateFixedVsExclude(fixedNums, excludeNums) {
      const a = new Set(Array.isArray(fixedNums) ? fixedNums : []);
      const b = new Set(Array.isArray(excludeNums) ? excludeNums : []);
      const overlap = Array.from(a).filter((n) => b.has(n));
      if (overlap.length) {
        showAlert(`고정 번호와 제외 번호가 겹치면 안돼요. 겹치는 값: ${overlap.join(', ')}`);
        return false;
      }
      return true;
    }

    function unionNumbers(a, b) {
      const s = new Set();
      (Array.isArray(a) ? a : []).forEach((n) => s.add(Number(n)));
      (Array.isArray(b) ? b : []).forEach((n) => s.add(Number(n)));
      const out = Array.from(s).filter((n) => Number.isInteger(n));
      out.sort((x, y) => x - y);
      return out;
    }

    function getDrawCount() {
      const raw = String(drawCountEl?.value ?? '1').trim();
      const n = Number.parseInt(raw || '1', 10);
      if (!Number.isInteger(n) || n < 1 || n > 50) {
        showAlert('몇 게임은 1~50 사이의 정수만 가능해요.');
        return null;
      }
      return n;
    }

    function renderHistory() {
      if (!historyEl) return;
      ensureHistoryItemIds();
      historyEl.innerHTML = '';
      if (historyEmptyEl) historyEmptyEl.style.display = history.length ? 'none' : 'block';

      history.forEach((item, idx) => {
        const row = document.createElement('div');
        row.className = 'history-item';

        const btnDelete = document.createElement('button');
        btnDelete.type = 'button';
        btnDelete.className = 'btn-secondary history-delete';
        btnDelete.textContent = '×';
        btnDelete.setAttribute('aria-label', '삭제');
        btnDelete.title = '삭제';
        btnDelete.addEventListener('click', async () => {
          const ok = await showConfirm('이 항목을 삭제할까요?', '삭제 확인');
          if (!ok) return;
          history.splice(idx, 1);
          renderHistory();
        });

        const left = document.createElement('div');
        left.className = 'history-left';

        const title = document.createElement('div');
        title.className = 'history-title';
        title.textContent = `#${idx + 1} 결과`;

        const nums = document.createElement('div');
        nums.className = 'numbers';
        nums.textContent = item.numbers.join(', ');

        left.appendChild(title);
        left.appendChild(nums);

        const actions = document.createElement('div');
        actions.className = 'history-actions';

        const select = document.createElement('select');
        select.setAttribute('aria-label', '재뽑기 제외 옵션');
        MODE_OPTIONS.forEach((opt) => {
          const o = document.createElement('option');
          o.value = opt.value;
          o.textContent = opt.label;
          select.appendChild(o);
        });
        select.value = item.mode;
        select.addEventListener('change', () => {
          item.mode = select.value;
        });

        const btnRandom = document.createElement('button');
        btnRandom.type = 'button';
        btnRandom.className = 'btn-secondary';
        btnRandom.textContent = '결과 번호 제외';

        const btnRedraw = document.createElement('button');
        btnRedraw.type = 'button';
        btnRedraw.className = 'btn-secondary';
        btnRedraw.textContent = '재뽑기';

        btnRandom.addEventListener('click', async () => {
          btnRandom.disabled = true;
          btnRandom.style.opacity = '0.7';
          try {
            const excludeNums = getCurrentResultNumbers();
            if (!excludeNums) {
              numbersEl.textContent = 'Error';
              resultEl.textContent = '현재 “결과”에 6개 번호가 없어서 제외할 수 없어요.';
              return;
            }

            const inputExclude = getExcludeNumbersFromInput();
            if (inputExclude === null) return;

            const fixedNums = getFixedNumbersFromInput();
            if (fixedNums === null) return;
            if (!validateFixedVsExclude(fixedNums, inputExclude)) return;

            const combinedExclude = unionNumbers(inputExclude, excludeNums);

            const { res, json } = await postDraw({
              exclude_mode: select.value,
              exclude_numbers: combinedExclude,
              exclude_draws: (() => {
                const d = getExcludeDrawsFromHistorySelection();
                return d.length ? d : undefined;
              })(),
              fixed_numbers: fixedNums.length ? fixedNums : undefined,
              advanced_options: getAdvancedOptionsFromUI(),
            });
            if (!res.ok || !json.success) {
              numbersEl.textContent = 'Error';
              resultEl.textContent = JSON.stringify(json, null, 2);
              return;
            }

            const newNumbers = showDrawResult(json);
            if (!newNumbers) return;
            const noteParts = [];
            if (inputExclude.length) noteParts.push(`exclude_input=${inputExclude.join(',')}`);
            noteParts.push(`exclude_current_result=${excludeNums.join(',')}`);
            history.push({ numbers: newNumbers, mode: select.value, note: noteParts.join(' | ') });
            renderHistory();
          } catch (e) {
            numbersEl.textContent = 'Error';
            resultEl.textContent = String(e);
          } finally {
            btnRandom.disabled = false;
            btnRandom.style.opacity = '1';
          }
        });

        btnRedraw.addEventListener('click', async () => {
          btnRedraw.disabled = true;
          btnRedraw.style.opacity = '0.7';
          try {
            const inputExclude = getExcludeNumbersFromInput();
            if (inputExclude === null) return;

            const fixedNums = getFixedNumbersFromInput();
            if (fixedNums === null) return;
            if (!validateFixedVsExclude(fixedNums, inputExclude)) return;

            const combinedExclude = unionNumbers(inputExclude, item.numbers);

            const { res, json } = await postDraw({
              exclude_mode: select.value,
              exclude_numbers: combinedExclude,
              exclude_draws: (() => {
                const d = getExcludeDrawsFromHistorySelection();
                return d.length ? d : undefined;
              })(),
              fixed_numbers: fixedNums.length ? fixedNums : undefined,
              advanced_options: getAdvancedOptionsFromUI(),
            });
            if (!res.ok || !json.success) {
              numbersEl.textContent = 'Error';
              resultEl.textContent = JSON.stringify(json, null, 2);
              return;
            }

            const newNumbers = showDrawResult(json);
            if (!newNumbers) return;

            const noteParts = [];
            if (inputExclude.length) noteParts.push(`exclude_input=${inputExclude.join(',')}`);
            noteParts.push(`exclude=${item.numbers.join(',')}`);
            history.push({ numbers: newNumbers, mode: select.value, note: noteParts.join(' | ') });
            renderHistory();
          } catch (e) {
            numbersEl.textContent = 'Error';
            resultEl.textContent = String(e);
          } finally {
            btnRedraw.disabled = false;
            btnRedraw.style.opacity = '1';
          }
        });

        actions.appendChild(select);
        actions.appendChild(btnRandom);
        actions.appendChild(btnRedraw);

        row.appendChild(left);
        row.appendChild(actions);
        row.appendChild(btnDelete);
        historyEl.appendChild(row);
      });

      renderHistoryExcludeUI();
    }

    redrawBtn?.addEventListener('click', async () => {
      setDrawingState(true);
      numbersEl.textContent = '뽑는 중...';
      resultEl.textContent = '';
      try {
        let excludeNums = [];
        try {
          excludeNums = parseExcludeNumbers(excludeNumbersEl?.value);
        } catch (e) {
          showAlert(String(e));
          return;
        }

        let fixedNums = [];
        try {
          fixedNums = parseFixedNumbers(fixedNumbersEl?.value);
        } catch (e) {
          showAlert(String(e));
          return;
        }
        if (!validateFixedVsExclude(fixedNums, excludeNums)) return;

        const count = getDrawCount();
        if (count === null) return;

        const payload = { exclude_mode: modeEl.value };
        if (excludeNums.length) payload.exclude_numbers = excludeNums;
        const excludeDraws = getExcludeDrawsFromHistorySelection();
        if (excludeDraws.length) payload.exclude_draws = excludeDraws;
        if (fixedNums.length) payload.fixed_numbers = fixedNums;
        if (count > 1) payload.count = count;
        payload.advanced_options = getAdvancedOptionsFromUI();

        const { res, json } = await postDraw(payload);
        if (!res.ok || !json.success) {
          numbersEl.textContent = 'Error';
          resultEl.textContent = JSON.stringify(json, null, 2);
          return;
        }

        const drawn = showDrawResult(json);
        if (!drawn) return;

        // If count > 1, append each draw to history.
        if (Array.isArray(drawn) && drawn.length && Array.isArray(drawn[0])) {
          drawn.forEach((row) => {
            if (Array.isArray(row) && row.length === 6) {
              history.push({ numbers: row.slice().sort((a, b) => a - b), mode: modeEl.value, note: excludeNums.length ? `exclude_input=${excludeNums.join(',')}` : undefined });
            }
          });
        } else if (Array.isArray(drawn) && drawn.length === 6) {
          history.push({ numbers: drawn, mode: modeEl.value, note: excludeNums.length ? `exclude_input=${excludeNums.join(',')}` : undefined });
        }
        renderHistory();
      } catch (e) {
        numbersEl.textContent = 'Error';
        resultEl.textContent = String(e);
      } finally {
        setDrawingState(false);
      }
    });

    randomBtn?.addEventListener('click', async () => {
      setDrawingState(true);
      numbersEl.textContent = '뽑는 중...';
      resultEl.textContent = '';
      try {
        const fixedNums = getFixedNumbersFromInput();
        if (fixedNums === null) return;
        const inputExclude = getExcludeNumbersFromInput();
        if (inputExclude === null) return;
        if (!validateFixedVsExclude(fixedNums, inputExclude)) return;

        const payload = { exclude_mode: 'NONE', advanced_options: getAdvancedOptionsFromUI() };
        if (fixedNums.length) payload.fixed_numbers = fixedNums;
        if (inputExclude.length) payload.exclude_numbers = inputExclude;
        const excludeDraws = getExcludeDrawsFromHistorySelection();
        if (excludeDraws.length) payload.exclude_draws = excludeDraws;

        const { res, json } = await postDraw(payload);
        if (!res.ok || !json.success) {
          numbersEl.textContent = 'Error';
          resultEl.textContent = JSON.stringify(json, null, 2);
          return;
        }

        const drawn = showDrawResult(json);
        if (!drawn) return;

        history.push({ numbers: drawn, mode: 'NONE' });
        renderHistory();
      } catch (e) {
        numbersEl.textContent = 'Error';
        resultEl.textContent = String(e);
      } finally {
        setDrawingState(false);
      }
    });
    loadHistory();
  </script>
</body>

</html>