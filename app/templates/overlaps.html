<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>겹치는 조합 목록</title>
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2064%2064'%3E%3Cdefs%3E%3CradialGradient%20id='g'%20cx='35%25'%20cy='30%25'%20r='80%25'%3E%3Cstop%20offset='0%25'%20stop-color='%232dd4bf'/%3E%3Cstop%20offset='55%25'%20stop-color='%237c5cff'/%3E%3Cstop%20offset='100%25'%20stop-color='%230b1220'/%3E%3C/radialGradient%3E%3C/defs%3E%3Ccircle%20cx='32'%20cy='32'%20r='28'%20fill='url(%23g)'/%3E%3Ccircle%20cx='32'%20cy='32'%20r='28'%20fill='none'%20stroke='rgba(234,240,255,0.25)'%20stroke-width='2'/%3E%3Ctext%20x='32'%20y='38'%20text-anchor='middle'%20font-family='system-ui,Segoe%20UI,Arial'%20font-size='18'%20font-weight='800'%20fill='%23eaf0ff'%3E6%2F45%3C/text%3E%3C/svg%3E" />
  <style>
    :root {
      --bg: #0b1220;
      --card: #0f1a2e;
      --text: #eaf0ff;
      --muted: #b8c3e6;
      --border: rgba(234, 240, 255, 0.16);
      --accent: #7c5cff;
      --accent-2: #2dd4bf;
    }

    :root {
      color-scheme: dark;
    }

    body {
      margin: 0;
      padding: 24px;
      line-height: 1.6;
      background: var(--bg);
      color: var(--text);
    }

    main {
      max-width: 860px;
      margin: 0 auto;
    }

    h1 {
      margin: 0 0 8px 0;
      letter-spacing: -0.02em;
    }

    .muted {
      color: var(--muted);
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      margin: 16px 0;
    }

    .divider {
      height: 1px;
      background: var(--border);
      margin: 14px 0;
    }

    .list {
      display: grid;
      gap: 10px;
    }

    .list-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
    }

    .list-title {
      font-weight: 800;
      letter-spacing: 0.01em;
    }

    .list-meta {
      margin-top: 6px;
      color: var(--muted);
      font-size: 13px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.03);
      font-weight: 700;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    details.overlap-details {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
    }

    details.overlap-details>summary {
      cursor: pointer;
      font-weight: 800;
    }

    details.overlap-details[open]>summary {
      margin-bottom: 10px;
    }

    button {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.03);
      color: var(--text);
      cursor: pointer;
    }

    button:focus {
      outline: 2px solid rgba(124, 92, 255, 0.45);
      outline-offset: 2px;
    }

    button {
      background: linear-gradient(135deg, rgba(124, 92, 255, 0.95), rgba(45, 212, 191, 0.9));
      border: 0;
      font-weight: 800;
    }

    button:active {
      transform: translateY(1px);
    }
  </style>
</head>

<body>
  <main>
    <header>
      <div style="display:flex; gap: 12px; align-items: center; justify-content: space-between; flex-wrap: wrap;">
        <div>
          <h1>겹치는 조합 목록</h1>
          <div class="muted">“열기”를 누르면 실제로 겹친 번호 조합과 해당 회차를 보여줘요.</div>
        </div>
        <div>
          <button id="goHome" type="button">홈으로</button>
        </div>
      </div>
    </header>

    <section class="card" aria-label="Overlap lists">
      <div class="list" id="overlapLists">
        <details class="overlap-details" id="detailFirst">
          <summary>1등 ↔ 1등 (완전 동일 6개)</summary>
          <div class="muted" id="detailFirstMeta">열면 불러옵니다.</div>
          <div class="list" id="listFirst"></div>
        </details>
        <details class="overlap-details" id="detailSecond">
          <summary>2등 ↔ 2등 (5개+보너스 6개)</summary>
          <div class="muted" id="detailSecondMeta">열면 불러옵니다.</div>
          <div class="list" id="listSecond"></div>
        </details>
        <details class="overlap-details" id="detailThird">
          <summary>3등 ↔ 3등 (동일 5개)</summary>
          <div class="muted" id="detailThirdMeta">열면 불러옵니다.</div>
          <div class="list" id="listThird"></div>
        </details>
        <details class="overlap-details" id="detailCross">
          <summary>2등 ↔ 3등 (교차 겹침: 동일 5개)</summary>
          <div class="muted" id="detailCrossMeta">열면 불러옵니다.</div>
          <div class="list" id="listCross"></div>
        </details>

        <div class="divider"></div>
        <h2>직전 회차와 중복 (Consecutive)</h2>

        <details class="overlap-details" id="detailConsecutive6">
          <summary>6개 중복 (직전 회차와 동일)</summary>
          <div class="muted" id="detailConsecutive6Meta">열면 불러옵니다.</div>
          <div class="list" id="listConsecutive6"></div>
        </details>
        <details class="overlap-details" id="detailConsecutive5">
          <summary>5개 중복</summary>
          <div class="muted" id="detailConsecutive5Meta">열면 불러옵니다.</div>
          <div class="list" id="listConsecutive5"></div>
        </details>
        <details class="overlap-details" id="detailConsecutive4">
          <summary>4개 중복</summary>
          <div class="muted" id="detailConsecutive4Meta">열면 불러옵니다.</div>
          <div class="list" id="listConsecutive4"></div>
        </details>
        <details class="overlap-details" id="detailConsecutive3">
          <summary>3개 중복</summary>
          <div class="muted" id="detailConsecutive3Meta">열면 불러옵니다.</div>
          <div class="list" id="listConsecutive3"></div>
        </details>
        <details class="overlap-details" id="detailConsecutive2">
          <summary>2개 중복</summary>
          <div class="muted" id="detailConsecutive2Meta">열면 불러옵니다.</div>
          <div class="list" id="listConsecutive2"></div>
        </details>
        <details class="overlap-details" id="detailConsecutive1">
          <summary>1개 중복</summary>
          <div class="muted" id="detailConsecutive1Meta">열면 불러옵니다.</div>
          <div class="list" id="listConsecutive1"></div>
        </details>
      </div>
    </section>
  </main>

  <script>
    let cachedOverlapData = null;

    document.getElementById('goHome')?.addEventListener('click', () => {
      window.location.href = '/';
    });

    function formatNumbers(nums) {
      if (!Array.isArray(nums)) return '—';
      return nums.join(', ');
    }

    function formatDraws(draws) {
      if (!Array.isArray(draws)) return '—';
      return draws.map((d) => `${d}회`).join(', ');
    }

    function clearEl(el) {
      if (!el) return;
      while (el.firstChild) el.removeChild(el.firstChild);
    }

    function renderOverlapList(containerId, metaId, items, kind) {
      const container = document.getElementById(containerId);
      const metaEl = document.getElementById(metaId);
      if (!container || !metaEl) return;

      clearEl(container);

      if (!Array.isArray(items) || items.length === 0) {
        metaEl.textContent = '겹치는 조합이 없어요.';
        return;
      }

      let pctMsg = '';
      if (cachedOverlapData && cachedOverlapData.total_draws > 0) {
        const pct = ((items.length / cachedOverlapData.total_draws) * 100).toFixed(1);
        pctMsg = ` 총 겹친거 ${pct}% 였습니다.`;
      }
      metaEl.textContent = `총 ${items.length}개 조합이 겹쳐요.${pctMsg}`;

      items.forEach((item) => {
        const card = document.createElement('div');
        card.className = 'list-item';

        const title = document.createElement('div');
        title.className = 'list-title';
        if (kind === 'consecutive') {
          title.textContent = `중복 번호: ${formatNumbers(item.overlapping_numbers)}`;
        } else {
          title.textContent = formatNumbers(item.numbers);
        }
        card.appendChild(title);

        const meta = document.createElement('div');
        meta.className = 'list-meta';

        if (kind === 'cross') {
          const chips = document.createElement('div');
          chips.className = 'chips';

          const c1 = document.createElement('span');
          c1.className = 'chip';
          c1.textContent = `2등 회차: ${formatDraws(item.second_draws)}`;
          chips.appendChild(c1);

          const c2 = document.createElement('span');
          c2.className = 'chip';
          c2.textContent = `3등 회차: ${formatDraws(item.third_draws)}`;
          chips.appendChild(c2);

          meta.appendChild(chips);
        } else if (kind === 'consecutive') {
          meta.textContent = `회차: ${item.draw_no}회 (직전 ${item.prev_draw_no}회와 중복)`;
          // Optionally show which numbers overlapped, or they are already in the title (numbers)
        } else {
          meta.textContent = `겹친 회차: ${formatDraws(item.draws)}`;
        }

        card.appendChild(meta);
        container.appendChild(card);
      });
    }

    async function ensureOverlapData() {
      if (cachedOverlapData) return cachedOverlapData;
      const res = await fetch('/analysis/overlap');
      const payload = await res.json();
      if (!res.ok || !payload.success) throw new Error('Failed to load overlap stats');
      cachedOverlapData = payload.data;
      return cachedOverlapData;
    }

    const mappings = [
      {
        detailId: 'detailFirst',
        listId: 'listFirst',
        metaId: 'detailFirstMeta',
        key: 'overlapping_1st_prize_combinations',
        kind: 'simple',
      },
      {
        detailId: 'detailSecond',
        listId: 'listSecond',
        metaId: 'detailSecondMeta',
        key: 'overlapping_2nd_prize_combinations',
        kind: 'simple',
      },
      {
        detailId: 'detailThird',
        listId: 'listThird',
        metaId: 'detailThirdMeta',
        key: 'overlapping_3rd_prize_combinations',
        kind: 'simple',
      },
      {
        detailId: 'detailCross',
        listId: 'listCross',
        metaId: 'detailCrossMeta',
        key: 'cross_overlaps_2nd_vs_3rd',
        kind: 'cross',
      },
      // Consecutive 6..1
      {
        detailId: 'detailConsecutive6',
        listId: 'listConsecutive6',
        metaId: 'detailConsecutive6Meta',
        get: (d) => d?.consecutive_overlaps?.[6] || [],
        kind: 'consecutive',
      },
      {
        detailId: 'detailConsecutive5',
        listId: 'listConsecutive5',
        metaId: 'detailConsecutive5Meta',
        get: (d) => d?.consecutive_overlaps?.[5] || [],
        kind: 'consecutive',
      },
      {
        detailId: 'detailConsecutive4',
        listId: 'listConsecutive4',
        metaId: 'detailConsecutive4Meta',
        get: (d) => d?.consecutive_overlaps?.[4] || [],
        kind: 'consecutive',
      },
      {
        detailId: 'detailConsecutive3',
        listId: 'listConsecutive3',
        metaId: 'detailConsecutive3Meta',
        get: (d) => d?.consecutive_overlaps?.[3] || [],
        kind: 'consecutive',
      },
      {
        detailId: 'detailConsecutive2',
        listId: 'listConsecutive2',
        metaId: 'detailConsecutive2Meta',
        get: (d) => d?.consecutive_overlaps?.[2] || [],
        kind: 'consecutive',
      },
      {
        detailId: 'detailConsecutive1',
        listId: 'listConsecutive1',
        metaId: 'detailConsecutive1Meta',
        get: (d) => d?.consecutive_overlaps?.[1] || [],
        kind: 'consecutive',
      },
    ];

    function attachOverlapDetailsHandlers() {

      mappings.forEach((m) => {
        const detail = document.getElementById(m.detailId);
        if (!detail) return;
        detail.addEventListener('toggle', async () => {
          if (!detail.open) return;
          try {
            const data = await ensureOverlapData();
            const items = m.get ? m.get(data) : (data?.[m.key] ?? []);
            renderOverlapList(m.listId, m.metaId, items, m.kind);
          } catch (e) {
            const metaEl = document.getElementById(m.metaId);
            if (metaEl) metaEl.textContent = String(e);
          }
        });
      });
    }

    attachOverlapDetailsHandlers();

    // Auto-load counts on page start
    (async function init() {
      try {
        const data = await ensureOverlapData();
        if (!data) return;

        // Helper to update summary text
        const updateSummary = (id, count) => {
          const detail = document.getElementById(id);
          if (detail) {
            const summary = detail.querySelector('summary');
            if (summary) {
              let originalText = summary.textContent;
              // Remove existing count in parentheses if any
              const match = originalText.match(/^(.*?)\s*\((\d+|직전 회차와 동일)(,\s*\d+)?\)$/);
              if (match) {
                originalText = match[1]; // Get text before the first parenthesis
              }
              summary.textContent = `${originalText} (${count})`;
            }
          }
        };

        mappings.forEach(m => {
          const items = m.get ? m.get(data) : (data?.[m.key] ?? []);
          updateSummary(m.detailId, items.length);
        });

      } catch (e) {
        console.error(e);
      }
    })();

  </script>
</body>

</html>